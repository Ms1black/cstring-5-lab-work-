  
# Строки в С++ 

### Внимание, анекдот!

> — Вводите все через массивы char, никаких string.
> 
> — Почему?
> 
> — Потому что string — это для счастливых людей, а мы в МГТУ.



Текстовые строки в С++ могут быть реализованы в одном из двух видов:
<div align="center">
<img src="https://github.com/user-attachments/assets/f060f13c-de09-4393-bc5c-1ae00a717187" width="350px">
</div>

* __первый__ предполагает, что мы студенты МГТУ и строка определяется как символьный массив, который завершается нулевым символом ( '\0')
* __второй__ является частью библиотеки классов => не встроенный тип <=> херня, переделывай

-----
  
### Чтение наших строк с клавиатуры

----
<div>
<table align="center">
  <tr>
    <td>
     <table>
        <tr>
            <th>$${\color{red}ЗАПРЕЩАЮ}$$❌</th>
            <th>$${\color{green}РАЗРЕШАЮ}$$✔️</th>
        </tr>
        <tr>
            <td>
          
```cpp
#include <iostream>
          
int main()
{
char str[80];
          
std::cin >> str;
          
std::cout << str;
          
return 0;
}
```
</td>
     <td>
          
```cpp
#include <iostream>
          
int main()
{
char str[80];
          
std::cin.getline(str, 80);
          
std::cout << str;
          
return 0;
}
```
</td>
        </tr>
      </table>
 </td>
<td style="padding-left: 20px;">
    <img src="https://github.com/user-attachments/assets/22411220-6d0c-4a36-8592-dac9f2a3af45" width="250px">
</td>
</tr> </table>
</div>

Почему так? В варианте слева программа формально корректна, __НО__ оператор `>>` прекращает считывание строки, как только встречает символ `пробела`,`табуляции`, `новой строки`

А во втором примере `cin.getline()` позволяет считывать строки, включая пробелы. Если формально описывать ее функционал, то она извлекает данные из входного потока до строкового разделителя, который не записывается в получившийся массив данных.

----

### Функции для работы с текстовыми строками  
-----

| Функция | Заголовок | Описание | Пример использования |
| ----------- | ----------- | ----------- | ----------- |
| `strcpy(s1,s2)`    | `<cstring>`   | Копирование строки s2 в строку s1  | ----------- |
| `strcat(s1,s2)`    | `<cstring>`   | Строка s2 присоединяется к строке s1  | ----------- |
| `strcmp(s1,s2)`    | `<cstring>`   | Сравнение строк s1 и s2: если строки равны, возвращается значение 0  | ----------- |
| `strchr(s1,ch)`    | `<cstring>`   | Указатель на первую позицию символа ch в строке s  | ----------- |
| `strlen(s)`    | `<cstring>`   | Возвращает длину строки, указанной аргументом s  | ----------- |
| `atoi(s)`    | `<cstdlib>`   | Преобразование состоящей из цифр строки s в целое число типа int  | ----------- |
| `atol(s)`    | `<cstdlib>`   | Преобразование состоящей из цифр строки s в целое число типа long  | ----------- |
| `atof(s)`    | `<cstdlib>`   | Преобразование состоящей из цифр строки s в целое число типа double | ----------- |
| `tolower(ch)`    | `<cctype>`   | Преобразование буквенного символа ch к строчному формату  | ----------- |
| `toupper(ch)`    | `<cctype>`   | Преобразование буквенного символа ch к прописному формату  | ----------- |

-----


**Советую к прочтению:**

- [Про языковой стандарт (setlocale)](https://learn.microsoft.com/ru-ru/cpp/c-runtime-library/reference/setlocale-wsetlocale?view=msvc-170)
